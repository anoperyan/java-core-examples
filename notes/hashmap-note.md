# HashMap笔记

## key的hashCode计算公式

计算key的hashCode（同时高位参与散列）

```java 
// 获取系统hashCode
int h = key.hashCode;
// 与高位进行异或预算，获取hashCode
int hashCode = h ^ ( h >>> 16);
```

## hashtable槽位计算公式

```java 
// hashCode: 通过键的hashCode计算公式算得的hashCode。
// tab.length(): 当前hashtable的总长度。

int idx = key.hashCode & (tab.length() - 1); 
```

## hashtable扩容后条目槽位计算

当hashtable扩容时候，需要重新对每个条目重新分配哈希表槽位，此时，

1. 条目的槽位就在原来位置上。
2. 要么就在原来位置+旧hashtable的容量的位置上（因为新容量总是就容量的2倍）。 情况统计：

|条件|位置|说明|
|----|----|----|
|hashCode & oldCap == 0|不变|说明当前hashCode小于oldCap|
|hashCode & oldCap != 0|当前位置+oldCap|说明当前hashCode小于oldCap, 列表是成倍扩容的|

## 常见问题

### 什么是哈希？

哈希（散列）函数是把任意长度的数据散列在有限长度的域中。

### 哈希冲突可以避免么？

没有办法避免，比如将10个对象散列到9个哈希桶中，即便是最好的情况，也有一个桶中有两个对象。

#### 一个好一点的哈希算法考虑的点是哪些？

1. 越灵敏越好，只要输入稍微有一点不同，就能得到不同的结果。
2. 运算速度要快，即便一个超级长的输入值，也能够快速得到hash值。

#### HashMap中存储数据的结构是怎么样的？

对于jdk1.8而言，存储结构主体是一个哈希表，每个哈希桶是一个聊表或者红黑树，当一个哈希桶内部节点数量小于8时候，是一个链表，
大于8时自动升级为一个红黑树。

#### HashMap的初始长度是多少，是什么时候创建的？

#### 默认的负载因子是多少？有什么作用？

默认负载因子是0.75，负载因子是用来调节hashmap的时间性能和空间性能的一个参数，负载因子的负载范围在0-1之间， 负载因子越大，hash冲突的可能性就越大，空间利用率越高，但是同时时间性能下降越多，反之亦然。选择0.75为默认值，
是因为通过实验在7之后，hash冲突会显著上升。

#### 链表转红黑树要达到什么条件？

#### HashMap内部的Node有一个哈希值，他是数据的hash值么？他是怎么得到的？

#### 为什么要采用高低位异或来获取hashCode？

#### HashMap的put方法的流程是什么样的？















