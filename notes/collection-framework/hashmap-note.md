# HashMap笔记

## key的hashCode计算公式

计算key的hashCode（同时高位参与散列）

```java 
// 获取系统hashCode
int h = key.hashCode;
// 与高位进行异或预算，获取hashCode
int hashCode = h ^ ( h >>> 16);
```

## hashtable槽位计算公式

```java 
// hashCode: 通过键的hashCode计算公式算得的hashCode。
// tab.length(): 当前hashtable的总长度。

int idx = key.hashCode & (tab.length() - 1); 
```

## hashtable扩容后条目槽位计算

当hashtable扩容时候，需要重新对每个条目重新分配哈希表槽位，此时，

1. 条目的槽位就在原来位置上。
2. 要么就在原来位置+旧hashtable的容量的位置上（因为新容量总是就容量的2倍）。 情况统计：

|条件|位置|说明|
|----|----|----|
|hashCode & oldCap == 0|不变|说明当前hashCode小于oldCap|
|hashCode & oldCap != 0|当前位置+oldCap|说明当前hashCode小于oldCap, 列表是成倍扩容的|

## 常见问题

### 什么是哈希？

哈希（散列）函数是把任意长度的数据散列在有限长度的域中。

### 哈希冲突可以避免么？

没有办法避免，比如将10个对象散列到9个哈希桶中，即便是最好的情况，也有一个桶中有两个对象。

#### 一个好一点的哈希算法考虑的点是哪些？

1. 越灵敏越好，只要输入稍微有一点不同，就能得到不同的结果。
2. 运算速度要快，即便一个超级长的输入值，也能够快速得到hash值。

#### HashMap中存储数据的结构是怎么样的？

对于jdk1.8而言，存储结构主体是一个哈希表，每个哈希桶是一个聊表或者红黑树，当一个哈希桶内部节点数量小于8时候，是一个链表， 大于8时自动升级为一个红黑树。

### HashMap的工作原理是怎么样的？

HashMap底层是通过数组+单向链表来实现的，在数组中的每一个元素都是一个链表结构，链表中的每一个节点又是一个Entry对象， 而这个Entry对象是真正用来存储K,V值的。
在HashMap中有两个比较重要的方法，一个是put方法，一个是get方法，对于put方法，在存储键值对时候，我们首先会调用一个
hash方法，通过这个hash方法，可以计算出key的hash值，从而得到一个十进制的数字，用这个数字和数组长度-1取模，就可以
得到数组下标，然后我们根据这个下标去找到数组中存储的单向链表，把链表中的每一个key和将要插入的key进行一个equals比较， 如果是相等的话，我们直接更新这个value值，如果不相等，我们就把新的值put到链表中去。
在put过程中，当hash表中存储的键值对长度超过了数组长度乘以负载因子的时候，就会将这个数组扩容为原来的两倍。还有就是， 对于哈希桶，也就是这个链表，如果链表长度超过8，系统会自动将这个链表升级为一个红黑树。
对于get方法，首先，同样也会调用hash方法，计算出当前key所对应数组下标，然后再遍历这个哈数桶的链表或者红黑树， 并对其中的key和给定的key进行equals比较，如果相同则返回当前entry的值，否则返回空。
总结起来就是，HashMap的核心原理是使用hash算法获取哈希桶的位置，然后使用equals比较来解决哈希冲突。

### 为什么要将链表转化为红黑树？

红黑树是二叉查找树的一种，他的查找算法的时间复杂度为O(logn)， 在数量比较多的时候他比查找时间复杂度为O(n)数组的性能要好。

### 为什么不直接使用红黑树？或者为什么要使用红黑树，而不是使用其他的二叉树比如二叉搜索树，或者AVL树。

不直接使用红黑树，是一种时间和空间的折中考虑，红黑树结构复杂，在一个哈希桶中的Entry少时候，使用红黑树来维护性价比不高。

#### 默认的负载因子是多少？有什么作用？

默认负载因子是0.75，负载因子是用来调节hashmap的时间性能和空间性能的一个参数，负载因子的负载范围在0-1之间， 负载因子越大，hash冲突的可能性就越大，空间利用率越高，但是同时时间性能下降越多，反之亦然。选择0.75为默认值，
是因为通过实验在7之后，hash冲突会显著上升。

#### 为什么要采用高低位异或来获取hashCode？

### ConcurrentHashMap为什么使用synchronized而不是ReentrantLock？

### synchronized对锁做了哪些优化？














